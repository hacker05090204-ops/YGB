# CI/CD Coverage Enforcement Workflow
#
# Triggers on push/PR to main.
# Fails if Python coverage <95%, C++ coverage <85%, or JS/TS coverage <80%.
# Prints all coverage values explicitly before failing.
# Branch protection: require status checks before merge.
#
# Step order (Phase 4):
#   1. Runtime safety tests
#   2. Python coverage
#   3. C++ coverage
#   4. JS/TS coverage
#   5. Print summary
#   6. Run coverage_gate.py (final gate)

name: Coverage Gate

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  coverage-gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install system dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -y gcovr g++

      - name: Install Python dependencies
        run: |
          pip install pytest pytest-cov coverage gcovr
          pip install -r requirements.txt || true

      # ========== PHASE 3: WORKING DIRECTORY DIAGNOSTICS ==========
      - name: Debug working directory
        run: |
          echo "PWD:"
          pwd
          echo "Files:"
          ls -R
          echo "---"

      # ========== PHASE 4 STEP 1: RUNTIME SAFETY TESTS (before coverage) ==========
      - name: Runtime safety tests
        run: pytest backend/tests/test_runtime_safety.py -v

      # ========== PHASE 4 STEP 2: PYTHON COVERAGE ==========
      - name: Python coverage check (>=95%)
        id: python_cov
        continue-on-error: true
        run: |
          echo "=== PYTHON COVERAGE ==="
          python -m pytest backend/tests/ \
            --cov=backend \
            --cov-report=xml:coverage_python.xml \
            --cov-report=json:coverage_python.json \
            --cov-report=term-missing \
            -v --tb=short
          echo "---"
          coverage report || true

      # ========== PHASE 4 STEP 3: C++ COVERAGE ==========
      - name: Build and run C++ self-tests with coverage
        id: cpp_cov
        continue-on-error: true
        run: |
          chmod +x scripts/build_cpp_tests.sh
          bash scripts/build_cpp_tests.sh

      # ========== PHASE 4 STEP 4: JS/TS COVERAGE ==========
      - name: JS/TS coverage check (>=80%)
        id: js_cov
        continue-on-error: true
        run: |
          echo "=== JS/TS COVERAGE ==="
          if [ -d frontend ]; then
            cd frontend
            npm ci
            npm test -- --coverage 2>&1 || true
            cat coverage/coverage-summary.json 2>/dev/null || echo "No JS/TS coverage data"
          else
            echo "No frontend directory â€” skipping JS/TS coverage"
          fi

      # ========== PHASE 4 STEP 5: PRINT SUMMARY ==========
      - name: Print all coverage values
        run: |
          echo "============================================"
          echo "        COVERAGE SUMMARY"
          echo "============================================"

          echo ""
          echo "=== PYTHON COVERAGE ==="
          if [ -f coverage_python.json ]; then
            python3 -c "
          import json
          with open('coverage_python.json') as f:
              d = json.load(f)
          pct = d.get('totals', {}).get('percent_covered', 0)
          print(f'  Python: {pct:.1f}% (threshold: 95%)')
          print(f'  Status: {\"PASS\" if pct >= 95 else \"FAIL\"}')" || echo "  Python: could not parse"
          else
            echo "  Coverage artifact missing: coverage_python.json"
            echo "  Python: NO DATA"
          fi

          echo ""
          echo "=== C++ COVERAGE ==="
          if [ -f coverage_cpp.json ]; then
            python3 -c "
          import json
          with open('coverage_cpp.json') as f:
              d = json.load(f)
          lt = d.get('line_total', 0)
          lc = d.get('line_covered', 0)
          pct = (lc/lt*100) if lt > 0 else 0
          print(f'  C++: {pct:.1f}% (threshold: 85%)')
          print(f'  Status: {\"PASS\" if pct >= 85 else \"FAIL\"}')" || echo "  C++: could not parse"
          else
            echo "  Coverage artifact missing: coverage_cpp.json"
            echo "  C++: NO DATA (compile or gcovr failed)"
          fi

          echo ""
          echo "=== JS/TS COVERAGE ==="
          if [ -f frontend/coverage/coverage-summary.json ]; then
            python3 -c "
          import json
          with open('frontend/coverage/coverage-summary.json') as f:
              d = json.load(f)
          pct = d.get('total', {}).get('lines', {}).get('pct', 0)
          print(f'  JS/TS: {pct:.1f}% (threshold: 80%)')
          print(f'  Status: {\"PASS\" if pct >= 80 else \"FAIL\"}')" || echo "  JS/TS: could not parse"
          else
            echo "  Coverage artifact missing: frontend/coverage/coverage-summary.json"
            echo "  JS/TS: NO DATA"
          fi

          echo ""
          echo "============================================"

      # ========== PHASE 4 STEP 6: COVERAGE GATE (final) ==========
      - name: Run coverage gate script
        run: python scripts/coverage_gate.py

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            coverage_python.json
            coverage_python.xml
            coverage_cpp.json
            frontend/coverage/
            reports/coverage_report.json

  governance-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -r requirements.txt || true

      # Phase 2: Use pytest instead of python -m for all test execution
      - name: Governance lock verification
        run: pytest backend/tests/test_governance_lock.py -v

      - name: Full pipeline integration
        run: pytest backend/tests/test_full_pipeline.py -v

      - name: Error path coverage
        run: pytest backend/tests/test_error_paths.py -v

      - name: Parallel scheduler stress
        run: pytest backend/tests/test_parallel_scheduler_stress.py -v

      - name: Runtime safety tests
        run: pytest backend/tests/test_runtime_safety.py -v
