/*
 * deterministic_exploit_engine.cpp — Deterministic Exploit Verification (Phase
 * 3)
 *
 * ██████████████████████████████████████████████████████████████████████
 * BOUNTY-READY — DETERMINISTIC EXPLOIT VERIFICATION ENGINE
 * ██████████████████████████████████████████████████████████████████████
 *
 * Performance-critical (C++):
 *   1. 3x replay — execute exploit 3 times, compare results
 *   2. Response hash comparison — SHA-256 hash of each response
 *   3. Privilege delta detection — compare before/after privileges
 *   4. Header perturbation replay — vary headers, verify consistency
 *   5. Confidence downgrade — reduce confidence if non-deterministic
 *
 * Compile (Windows):
 *   g++ -shared -O2 -o deterministic_exploit_engine.dll
 * deterministic_exploit_engine.cpp
 */

#include <cmath>
#include <cstdio>
#include <cstring>


#ifdef _WIN32
#define DEE_EXPORT __declspec(dllexport)
#else
#define DEE_EXPORT __attribute__((visibility("default")))
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================== */
/*  CONSTANTS                                                         */
/* ================================================================== */

#define REPLAY_COUNT 3 /* Number of replays */
#define MAX_HASH_LEN 65
#define MAX_RESPONSE_LEN 8192
#define MAX_PERTURBATIONS 5         /* Header perturbation variants */
#define DETERMINISTIC_THRESHOLD 1.0 /* All 3 must match */
#define PARTIAL_THRESHOLD 0.67      /* 2/3 match */

/* ================================================================== */
/*  STATE                                                             */
/* ================================================================== */

typedef struct {
  int verified; /* 1 = deterministic, 0 = not */
  int replays_run;
  int replays_matched;
  int privilege_delta;        /* 1 = privilege escalation detected */
  int header_stable;          /* 1 = consistent across perturbations */
  double confidence;          /* 0.0–1.0 */
  double original_confidence; /* Before adjustment */
  char replay_hashes[REPLAY_COUNT][MAX_HASH_LEN];
  char violation[256];
} ExploitVerification;

static ExploitVerification g_verify;

/* ================================================================== */
/*  HASH UTILITY                                                      */
/* ================================================================== */

/* djb2 double-hash for fast response comparison */
static void response_hash(const char *data, int len, char out[MAX_HASH_LEN]) {
  unsigned long h1 = 5381, h2 = 0x9e3779b9;
  for (int i = 0; i < len; i++) {
    h1 = ((h1 << 5) + h1) + (unsigned char)data[i];
    h2 ^= ((h2 << 6) + (h2 >> 2) + (unsigned char)data[i]);
  }
  snprintf(out, MAX_HASH_LEN, "%016lx%016lx%016lx%016lx", h1, h2, h1 ^ h2,
           h1 + h2);
}

/* ================================================================== */
/*  REPLAY VERIFICATION                                               */
/* ================================================================== */

/*
 * record_replay — Record a response hash from one replay attempt.
 * replay_idx: 0, 1, or 2
 * response: raw response data
 * response_len: length of response
 */
DEE_EXPORT void record_replay(int replay_idx, const char *response,
                              int response_len) {
  if (replay_idx < 0 || replay_idx >= REPLAY_COUNT)
    return;
  response_hash(response, response_len, g_verify.replay_hashes[replay_idx]);
  g_verify.replays_run++;
}

/*
 * verify_replays — Compare all recorded replay hashes.
 * Returns: number of matching replays (3 = fully deterministic)
 */
DEE_EXPORT int verify_replays(void) {
  if (g_verify.replays_run < REPLAY_COUNT) {
    snprintf(g_verify.violation, sizeof(g_verify.violation),
             "Insufficient replays: %d/%d", g_verify.replays_run, REPLAY_COUNT);
    return 0;
  }

  int matches = 0;
  /* Compare all pairs */
  int match_01 =
      (strcmp(g_verify.replay_hashes[0], g_verify.replay_hashes[1]) == 0);
  int match_02 =
      (strcmp(g_verify.replay_hashes[0], g_verify.replay_hashes[2]) == 0);
  int match_12 =
      (strcmp(g_verify.replay_hashes[1], g_verify.replay_hashes[2]) == 0);

  if (match_01 && match_02 && match_12) {
    matches = 3; /* All identical — fully deterministic */
  } else if (match_01 || match_02 || match_12) {
    matches = 2; /* Partial — at least 2 match */
  } else {
    matches = 0; /* All different — non-deterministic */
  }

  g_verify.replays_matched = matches;
  return matches;
}

/* ================================================================== */
/*  PRIVILEGE DELTA DETECTION                                         */
/* ================================================================== */

/*
 * check_privilege_delta — Detect privilege escalation.
 *
 * before_level: privilege level before exploit (0=none, 1=user, 2=admin,
 * 3=root) after_level: privilege level after exploit Returns: 1 if escalation
 * detected, 0 if not
 */
DEE_EXPORT int check_privilege_delta(int before_level, int after_level) {
  g_verify.privilege_delta = (after_level > before_level) ? 1 : 0;
  return g_verify.privilege_delta;
}

/* ================================================================== */
/*  HEADER PERTURBATION                                               */
/* ================================================================== */

static char g_perturbation_hashes[MAX_PERTURBATIONS][MAX_HASH_LEN];
static int g_perturbation_count = 0;

DEE_EXPORT void perturbation_reset(void) {
  g_perturbation_count = 0;
  memset(g_perturbation_hashes, 0, sizeof(g_perturbation_hashes));
}

/*
 * record_perturbation — Record response hash from a header-perturbed request.
 */
DEE_EXPORT void record_perturbation(const char *response, int response_len) {
  if (g_perturbation_count >= MAX_PERTURBATIONS)
    return;
  response_hash(response, response_len,
                g_perturbation_hashes[g_perturbation_count]);
  g_perturbation_count++;
}

/*
 * verify_perturbation_stability — Check if exploit is stable across
 * perturbations. Returns: ratio of matching perturbation responses (1.0 = fully
 * stable)
 */
DEE_EXPORT double verify_perturbation_stability(void) {
  if (g_perturbation_count < 2)
    return 1.0;

  int matches = 0;
  for (int i = 1; i < g_perturbation_count; i++) {
    if (strcmp(g_perturbation_hashes[0], g_perturbation_hashes[i]) == 0) {
      matches++;
    }
  }

  double stability = (double)(matches + 1) / g_perturbation_count;
  g_verify.header_stable = (stability >= 0.8) ? 1 : 0;
  return stability;
}

/* ================================================================== */
/*  CONFIDENCE ADJUSTMENT                                             */
/* ================================================================== */

/*
 * compute_verified_confidence — Compute final confidence with determinism
 * penalty.
 *
 * original_confidence: model's raw confidence (0-1)
 * Returns: adjusted confidence after deterministic verification
 */
DEE_EXPORT double compute_verified_confidence(double original_confidence) {
  g_verify.original_confidence = original_confidence;

  double replay_factor = (double)g_verify.replays_matched / REPLAY_COUNT;
  double priv_factor =
      g_verify.privilege_delta ? 1.1 : 0.9; /* Boost if priv esc */
  double header_factor = g_verify.header_stable ? 1.0 : 0.7;

  /* Base confidence × replay consistency × privilege × header stability */
  double adjusted =
      original_confidence * replay_factor * priv_factor * header_factor;

  /* Clamp to [0, 1] */
  if (adjusted > 1.0)
    adjusted = 1.0;
  if (adjusted < 0.0)
    adjusted = 0.0;

  g_verify.confidence = adjusted;
  return adjusted;
}

/* ================================================================== */
/*  FULL VERIFICATION PIPELINE                                        */
/* ================================================================== */

/*
 * full_exploit_verification — Run complete deterministic verification.
 *
 * Returns: 1 if exploit is verified deterministic, 0 if not.
 */
DEE_EXPORT int full_exploit_verification(double original_confidence) {
  memset(g_verify.violation, 0, sizeof(g_verify.violation));

  /* Check replay consistency */
  int matches = verify_replays();

  /* Check perturbation stability */
  double stability = verify_perturbation_stability();

  /* Compute final confidence */
  double final_conf = compute_verified_confidence(original_confidence);

  /* Verdict */
  if (matches >= REPLAY_COUNT && stability >= 0.8) {
    g_verify.verified = 1;
  } else if (matches >= 2 && stability >= 0.6) {
    g_verify.verified = 0; /* Partial — not sufficient */
    snprintf(g_verify.violation, sizeof(g_verify.violation),
             "Partial determinism: %d/%d replays, stability=%.2f", matches,
             REPLAY_COUNT, stability);
  } else {
    g_verify.verified = 0;
    snprintf(g_verify.violation, sizeof(g_verify.violation),
             "Non-deterministic: %d/%d replays, stability=%.2f", matches,
             REPLAY_COUNT, stability);
  }

  return g_verify.verified;
}

/* ================================================================== */
/*  STATUS QUERIES                                                    */
/* ================================================================== */

DEE_EXPORT int dee_is_verified(void) { return g_verify.verified; }
DEE_EXPORT int dee_replays_matched(void) { return g_verify.replays_matched; }
DEE_EXPORT int dee_privilege_delta(void) { return g_verify.privilege_delta; }
DEE_EXPORT int dee_header_stable(void) { return g_verify.header_stable; }

DEE_EXPORT double dee_confidence(void) { return g_verify.confidence; }
DEE_EXPORT double dee_original_confidence(void) {
  return g_verify.original_confidence;
}

DEE_EXPORT void dee_reset(void) {
  memset(&g_verify, 0, sizeof(g_verify));
  perturbation_reset();
}

DEE_EXPORT void dee_get_violation(char *out, int len) {
  strncpy(out, g_verify.violation, len - 1);
  out[len - 1] = '\0';
}

#ifdef __cplusplus
}
#endif
