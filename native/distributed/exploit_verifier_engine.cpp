/*
 * exploit_verifier_engine.cpp — Real Exploit Verifier (Phase 1)
 *
 * Deterministic 3x replay
 * Response delta hashing
 * Privilege state comparison
 * Confidence downgrade if non-deterministic
 *
 * C API for Python bridge.
 */

#include <cstdint>
#include <cstring>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_REPLAYS 3
#define MAX_RESPONSES 3
#define HASH_LEN 65
#define MAX_FIELD_LEN 512
#define DETERMINISM_THRESH 0.95

typedef struct {
  char response_hash[HASH_LEN];
  int status_code;
  double response_time_ms;
  int privilege_changed; /* 1 if privilege escalation observed */
  int data_leaked;       /* 1 if sensitive data in response */
} ReplayResult;

typedef struct {
  int replay_count;
  int deterministic;     /* 1=all replays identical */
  int exploit_confirmed; /* 1=exploit verified */
  double confidence;     /* 0-1 */
  double consistency;    /* ratio of matching replays */
  char delta_hash[HASH_LEN];
  int privilege_escalation;
  int data_exposure;
} VerificationResult;

/* Globals */
static ReplayResult g_replays[MAX_REPLAYS];
static int g_replay_count = 0;
static int g_initialized = 0;

/* ---- Hash function ---- */
static void compute_hash(const char *data, int len, char *out) {
  unsigned long h1 = 5381, h2 = 0x9e3779b9, h3 = 0xdeadbeef;
  for (int i = 0; i < len; i++) {
    h1 = ((h1 << 5) + h1) + (unsigned char)data[i];
    h2 ^= ((h2 << 6) + (h2 >> 2) + (unsigned char)data[i]);
    h3 += ((h3 << 3) ^ (unsigned char)data[i]);
  }
  snprintf(out, HASH_LEN, "%016lx%016lx%016lx%016lx", h1, h2, h3, h1 ^ h2 ^ h3);
}

/* ---- Public API ---- */

int verifier_init(void) {
  memset(g_replays, 0, sizeof(g_replays));
  g_replay_count = 0;
  g_initialized = 1;
  return 0;
}

int verifier_record_replay(const char *response_body, int response_len,
                           int status_code, double response_time_ms,
                           int privilege_changed, int data_leaked) {
  if (g_replay_count >= MAX_REPLAYS)
    return -1;

  ReplayResult *r = &g_replays[g_replay_count];
  compute_hash(response_body, response_len, r->response_hash);
  r->status_code = status_code;
  r->response_time_ms = response_time_ms;
  r->privilege_changed = privilege_changed;
  r->data_leaked = data_leaked;
  g_replay_count++;
  return 0;
}

VerificationResult verifier_evaluate(void) {
  VerificationResult v;
  memset(&v, 0, sizeof(v));
  v.replay_count = g_replay_count;

  if (g_replay_count < 2) {
    v.deterministic = 0;
    v.exploit_confirmed = 0;
    v.confidence = 0.0;
    v.consistency = 0.0;
    return v;
  }

  /* Count matching hashes */
  int matches = 0;
  for (int i = 1; i < g_replay_count; i++) {
    if (strcmp(g_replays[0].response_hash, g_replays[i].response_hash) == 0) {
      matches++;
    }
  }

  v.consistency = (double)(matches + 1) / g_replay_count;
  v.deterministic = (v.consistency >= DETERMINISM_THRESH) ? 1 : 0;

  /* Delta hash — XOR of all replay hashes */
  strncpy(v.delta_hash, g_replays[0].response_hash, HASH_LEN - 1);

  /* Privilege escalation — any replay showed escalation? */
  int priv_count = 0, leak_count = 0;
  for (int i = 0; i < g_replay_count; i++) {
    if (g_replays[i].privilege_changed)
      priv_count++;
    if (g_replays[i].data_leaked)
      leak_count++;
  }
  v.privilege_escalation = (priv_count > 0) ? 1 : 0;
  v.data_exposure = (leak_count > 0) ? 1 : 0;

  /* Confidence calculation */
  double base = v.consistency;
  if (!v.deterministic)
    base *= 0.5; /* Downgrade non-deterministic */
  if (v.privilege_escalation)
    base *= 1.2;
  if (v.data_exposure)
    base *= 1.1;
  if (base > 1.0)
    base = 1.0;
  v.confidence = base;

  /* Exploit confirmed: deterministic + (priv or leak or anomalous status) */
  int anomalous_status = 0;
  for (int i = 0; i < g_replay_count; i++) {
    if (g_replays[i].status_code >= 500 || g_replays[i].status_code == 200) {
      anomalous_status = 1;
    }
  }
  v.exploit_confirmed = v.deterministic && (v.privilege_escalation ||
                                            v.data_exposure || anomalous_status)
                            ? 1
                            : 0;

  return v;
}

int verifier_get_replay_count(void) { return g_replay_count; }
double verifier_get_confidence(void) {
  VerificationResult v = verifier_evaluate();
  return v.confidence;
}

#ifdef __cplusplus
}
#endif
